You are given an undirected unweighted graph consisting of A vertices and M edges given in a form of 2D Matrix B of size M x 2 where (B[i][0], B][i][1]) denotes two nodes connected by an edge.

You have to write a number on each vertex of the graph. Each number should be 1, 2 or 3. The graph becomes Poisonous if for each edge the sum of numbers on vertices connected by this edge is odd.

Calculate the number of possible ways to write numbers 1, 2 or 3 on vertices so the graph becomes poisonous. Since this number may be large, return it modulo 998244353.

NOTE:

Note that you have to write exactly one number on each vertex.
The graph does not have any self-loops or multiple edges.
Nodes are labelled from 1 to A.


Problem Constraints
1 <= A <= 3*105

0 <= M <= 3*105

1 <= B[i][0], B[i][1] <= A

B[i][0] != B[i][1]



Input Format
First argument is an integer A denoting the number of nodes.

Second argument is an 2D Matrix B of size M x 2 denoting the M edges.



Output Format
Return one integer denoting the number of possible ways to write numbers 1, 2 or 3 on the vertices of given graph so it becomes Poisonous . Since answer may be large, print it modulo 998244353.



Example Input
Input 1:

 A = 2
 B = [  [1, 2]
     ]
Input 2:

 A = 4
 B = [  [1, 2]
        [1, 3]
        [1, 4]
        [2, 3]
        [2, 4]
        [3, 4]
    ]


Example Output
Output 1:

 4
Output 2:

 0


Example Explanation
Explanation 1:

 There are 4 ways to make the graph poisonous. i.e, writing number on node 1 and 2 as,
    [1, 2] , [3, 2], [2, 1] or [2, 3] repsectively.
Explanation 2:

 There is no way to make the graph poisonous.
 /////////////////////////////////////////////////////
 public class Solution {
    int mod = 998244353;
    //https://youtu.be/nbgaEu-pvkU
    //FOR COUNTING ONES AND NO. OF NODES IN THE COMPONENET
    int ones, nodesCount;
    public int solve(int A, ArrayList < ArrayList < Integer >> B) {
        boolean visited[] = new boolean[A + 1];
        int color[] = new int[A + 1];
        HashMap < Integer, ArrayList < Integer >> graph = new HashMap < > ();
        boolean ans = true;
  for (int i = 1; i <= A; i++) {//initialize all to avoid null pointer
    //  int source = B.get(i).get(0), dest = B.get(i).get(1);
      graph.put(i, new ArrayList < > ());
   //   graph.put(dest, new ArrayList < > ());
  }
        //GRAPH PREP
        for (int i = 0; i < B.size(); i++) {
            int source = B.get(i).get(0), dest = B.get(i).get(1);
           // if (!graph.containsKey(source)) graph.put(source, new ArrayList < > ());
            graph.get(source).add(dest);
          //  if (!graph.containsKey(dest)) graph.put(dest, new ArrayList < > ());
            graph.get(dest).add(source);
        }

        //COUNTING DISCONNECTED COMPONENETS
        int size = graph.size();
        //IF ALL COMPONENETS ARE DISCONNECTED THE THER WILL 3^N WAYS
     //   if (size == 0) return fastExpo(3, A);
        Arrays.fill(color,-1);
       // discComp = A - size;
        long ways = 1;

        //CHECKING EVEREY NODE BECAUSE OF DISCONNECTED CASE
        //GOING THROUGH THE DEPTH OF EACH COMPONENET AND GETTING THE COUNT OF ONE
        for (int i = 1; i <= A; i++) {
            if (color[i]==-1) {
                ones = 1;
                nodesCount = 0;
                 color[i]=1;
                ans = ans & DFS(i, graph, visited, color);
                if (!ans) return 0;
                //as we have to multiply for each component
                ways = ways * 1L * ((fastExpo(2, ones) + fastExpo(2, nodesCount - ones)) % mod);
                ways %= mod;
            }
        }
        return (int)(ways % mod);
    }


    private boolean DFS(int source, HashMap < Integer, ArrayList < Integer >> graph, boolean[] visited, int[] color) {
       
        visited[source] = true;
        nodesCount++;
       // System.out.println(graph.get(1));
     
        //WHEN THERE IS NO NEB NODE CONNECTION 
     //   if (!graph.containsKey(source)) return true;
          
        //GOING THROUGH ALL THE NEB.
        for (int neb: graph.get(source)) {
            if (visited[neb]) {
                if (color[neb] == color[source]) return false;
            } else {
                color[neb] = 1 - color[source];
                //WHENEVER COLORED ONE INCREASE THE COUNT
                if (color[neb] == 1) ones++;
                if (!DFS(neb, graph, visited, color)) return false;
            }
        }
        return true;
    }

    //FOR GETTING THE POWER
    private int fastExpo(int a, int n) {
        if (n == 0) return 1;
        long ha = fastExpo(a, n / 2) % mod;
        long hp = (ha * ha) % mod;
        if ((n & 1) == 1) return (int)((hp * a) % mod);
        return (int) hp;
    }
}
    //FOR GETTING THE POWER
    private int fastExpo(int a, int n) {
        if (n == 0) return 1;
        long ha = fastExpo(a, n / 2) % mod;
        long hp = (ha * ha) % mod;
        if ((n & 1) == 1) return (int)((hp * a) % mod);
        return (int) hp;
    }
}
