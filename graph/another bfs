By dijkstra
Given a weighted undirected graph having A nodes, a source node C and destination node D.

Find the shortest distance from C to D and if it is impossible to reach node D from C then return -1.

You are expected to do it in Time Complexity of O(A + M).

Note:

There are no self-loops in the graph.

No multiple edges between two pair of vertices.

The graph may or may not be connected.

Nodes are Numbered from 0 to A-1.

Your solution will run on multiple testcases. If you are using global variables make sure to clear them.



Problem Constraints

1 <= A <= 105

0 <= B[i][0], B[i][1] < A

1 <= B[i][2] <= 2

0 <= C < A

0 <= D < A



Input Format

The first argument given is an integer A, representing the number of nodes.

The second argument given is the matrix B, where B[i][0] and B[i][1] are connected through an edge of weight B[i][2].

The third argument given is an integer C, representing the source node.

The fourth argument is an integer D, representing the destination node.

Note: B[i][2] will be either 1 or 2.



Output Format

Return the shortest distance from C to D. If it is impossible to reach node D from C then return -1.



Example Input

Input 1:

 
A = 6
B = [   [2, 5, 1]
        [1, 3, 1] 
        [0, 5, 2] 
        [0, 2, 2] 
        [1, 4, 1] 
        [0, 1, 1] ] 
C = 3
D = 2
Input 2:

A = 2
B = [   [0, 1, 1]
    ] 
C = 0
D = 1


Example Output

Output 1:

 4
Output 2:

 1


Example Explanation

Explanation 1:

The path to be followed will be:
    3 -> 1 (Edge weight : 1)
    1 -> 0 (Edge weight : 1)
    0 -> 2 (Edge weight : 2)
Total length of path = 1 + 1 + 2 = 4.
Explanation 2:

 Path will be 0-> 1.
/////////////////////solution////////////////////////////
public class Solution {
    public int solve(int A, int[][] B, int C, int D) {
  int d[] =  new int[A];
        //create adj list
           //create undirected weighed graph.
        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();
            for (int i = 0; i <= A; i++) {
            graph.add(new ArrayList<Pair>());
        }
     

       for(int i=0;i<B.length;i++){
           int src = B[i][0];
           int des = B[i][1];
           int weight = B[i][2];

           Pair p1= new Pair(des,weight);
           graph.get(src).add(p1);
           //both are same
           graph.get(des).add(new Pair(src,weight));
       }
       Arrays.fill(d,Integer.MAX_VALUE);
       d[C] = 0;
        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.dist-b.dist);
          pq.add(new Pair(C,0));
            while(! pq.isEmpty()){
                   Pair minWeighedNode = pq.remove();
                    for(Pair neigh:graph.get(minWeighedNode.u)){
                   if(minWeighedNode.dist>d[minWeighedNode.u]) continue;//already basted
                    if(d[neigh.u] >d[minWeighedNode.u]+neigh.dist){
                        d[neigh.u] = d[minWeighedNode.u]+neigh.dist;
                        pq.add(new Pair(neigh.u, d[neigh.u]));
                    }
                }
            }
             for(int i=0; i<d.length; i++){
            if(d[i] == Integer.MAX_VALUE){
                d[i] = -1;
            }
        }
            return d[D];
    }
}
class Pair{
    int u;

    int dist;
    Pair(int u,int dist){
        this.u = u;

        this.dist = dist;
    }
}
/////////////////////BFS////////////////////////
public class Solution {
    static int maxn = 200009;
    static int[] vis = new int[maxn];
    static ArrayList < ArrayList < Integer > > adj;
    public static void graph() {
        adj = new ArrayList < ArrayList < Integer > > ();
        for (int i = 0; i < maxn; i++) {
            vis[i] = 0;
            adj.add(new ArrayList < Integer > ());
        }
    }
    public int solve(int A, int[][] B, int C, int D) {
        graph();
        int n = A;
          int dummy = A;//coz nodes are numbered from 0 to A-1 so start fresh nodes from A
        for (int[] it: B) {
            int x = it[0];
            int y = it[1];
            int w = it[2];
          
            if (w == 1) {
                adj.get(x).add(y);
                adj.get(y).add(x);
            } else {
                adj.get(x).add(dummy);
                adj.get(dummy).add(x);
                adj.get(y).add(dummy);
                adj.get(dummy).add(y);
                dummy++;
            }
        }
        return bfs(C, D);
    }
    public static int bfs(int source, int destination) {
        vis[source] = 1;
        Queue < Pair > q = new ArrayDeque < Pair > ();
        q.offer(new Pair(source, 0));
        while (q.size() > 0) {
            Pair p = q.poll();
            int x = p.ff;
            int w = p.ss;
            if (x == destination)
                return w;
            for (int v: adj.get(x)) {
                if (vis[v] == 0) {
                    vis[v] = 1;
                    q.offer(new Pair(v, w + 1));
                }
            }
        }
        return -1;
    }
}
class Pair {
    int ff;
    int ss;
    public Pair(int a, int b) {
        this.ff = a;
        this.ss = b;
    }
}
