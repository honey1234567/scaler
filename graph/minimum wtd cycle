iven an integer A, representing number of vertices in a graph.

Also you are given a matrix of integers B of size N x 3 where N represents number of Edges in a Graph and Triplet (B[i][0], B[i][1], B[i][2]) implies there is an undirected edge between B[i][0] and B[i][1] and weight of that edge is B[i][2].

Find and return the weight of minimum weighted cycle and if there is no cycle return -1 instead.

NOTE: Graph may contain self loops but does not have duplicate edges.



Problem Constraints
1 <= A <= 1000

1 <= B[i][0], B[i][1] <= A

1 <= B[i][2] <= 100000



Input Format
The first argument given is the integer A.

The second argument given is the integer matrix B.



Output Format
Return the weight of minimum weighted cycle and if there is no cycle return -1 instead.



Example Input
Input 1:

 A = 4
 B = [  [1 ,2 ,2]
        [2 ,3 ,3]
        [3 ,4 ,1]
        [4 ,1 ,4]
        [1 ,3 ,15]  ]
Input 2:

 A = 3
 B = [  [1 ,2 ,2]
        [2 ,3 ,3]  ]


Example Output
Output 1:

 10 
Output 2:

 -1


Example Explanation
Explanation 1:

 Given graph forms 3 cycles
 1. 1 ---> 2 ---> 3 ---> 4 ---> 1 weight = 10
 2. 1 ---> 2 ---> 3 ---> 1 weight = 20
 3. 1 ---> 3---> 4 ---> 1 weight = 20
 so answer would be 10.
Explanation 2:

 Given graph forms 0 cycles so return -1.

public class Solution {
    public int solve(int A, int[][] B) {
              //create adj list
           //create undirected weighed graph.
          int maxVert = maxNodeValue(B)+1;
        // System.out.println(A);
       int minCycle = Integer.MAX_VALUE;
    //   Arrays.fill(d,Integer.MAX_VALUE);
       for(int i=0;i<B.length;i++){
            ArrayList<ArrayList<Pair>> graph = buildGraph(B,maxVert,i);
               int res = dijkstra(maxVert,B[i][0],graph,B[i][1]);
               if(res != -1)
                minCycle = Math.min(minCycle,res + B[i][2]);
       }
       return minCycle;
    }
    public  ArrayList<ArrayList<Pair>> buildGraph(int[][]B,int A,int removeIndex){
         ArrayList<ArrayList<Pair>> graph = new ArrayList<>();
            for (int i = 0; i <= A; i++) {
            graph.add(new ArrayList<Pair>());
        }
     

       for(int i=0;i<B.length;i++){
           if(i== removeIndex) continue;
           int src = B[i][0];
           int des = B[i][1];
           int weight = B[i][2];

           Pair p1= new Pair(des,weight);
           graph.get(src).add(p1);
           //both are same
           graph.get(des).add(new Pair(src,weight));
       }
       return graph;
    }
    public int dijkstra(int A,int C,ArrayList<ArrayList<Pair>>graph,int dest){
          int d[] =  new int[A];
           Arrays.fill(d,Integer.MAX_VALUE);
        d[C] = 0;
        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.dist-b.dist);
    
          pq.add(new Pair(C,0));
            while(! pq.isEmpty()){
                   Pair minWeighedNode = pq.remove();
                    for(Pair neigh:graph.get(minWeighedNode.u)){
                    if(d[neigh.u] >d[minWeighedNode.u]+neigh.dist){
                        d[neigh.u] = d[minWeighedNode.u]+neigh.dist;
                        pq.add(new Pair(neigh.u, d[neigh.u]));
                    }
                }
            }
            return d[dest] == Integer.MAX_VALUE?-1:d[dest];
    }
    public int maxNodeValue(int[][] B){
        int max = Integer.MIN_VALUE;
        for(int i=0;i<B.length;i++){
            for(int j=0;j<2;j++){
                max = Math.max(B[i][j],max);
            }
        }
        return max;
    }
}
class Pair{
    int u;

    int dist;
    Pair(int u,int dist){
        this.u = u;

        this.dist = dist;
    }
}
