Given a binary string A. It is allowed to do at most one swap between any 0 and 1. Find and return the length of the longest consecutive 1’s that can be achieved.


Input Format

The only argument given is string A.
Output Format

Return the length of the longest consecutive 1’s that can be achieved.
Constraints

1 <= length of string <= 1000000
A contains only characters 0 and 1.
For Example

Input 1:
    A = "111000"
Output 1:
    3

Input 2:
    A = "111011101"
Output 2:
    7
////////////////////MINE////////////////////
public class Solution {
    public int solve(String A) {
        int max = Integer.MIN_VALUE;;
        int n = A.length();
        for(int i=0;i<n;i++){
            if(A.charAt(i) == '0'){
                int l=0;
                int swap=0;
                int f=0;
                for(int j = i-1;j>=0;j--){
                if(A.charAt(j) != '0' && f==0){
                    l++;
                }else{
                    f=1;
                    if(A.charAt(j) == '1') {
                        swap=1;
                        break;
                    }
                }
            }//j loop close
            int r=0;
            f=0;
            for(int j=i+1;j<n;j++){
                 if(A.charAt(j) != '0' && f==0){
                    r++;
                }else{
                    f=1;
                    if(A.charAt(j) == '1') {
                        swap=1;
                        break;
                    }
                }
            }//j loop close
          int temp =0;
          if(swap == 1) temp = l+r+1;
          else temp = l+r;
          max= Math.max(temp,max);
            }//
        }//i loop
        if(max == Integer.MIN_VALUE) return n;
        return max;
    }//method close
}
//./Solution.java:12: error: incomparable types: char and String
// 
              //  if(A.charAt(j) != "0" && f==0){ solution is to use A.charAt(i) != '0'(single quote coz it's a character)

/////////////////////THEIRS///////////////////////////
Create two arrays which store the number of consecutive ones on the right and left of all indexes.

Now, for each index x having character ‘0’, the answer will be the maximum of answer and left consecutive ones of (x-1) + right consecutive ones of (x+1) + 1 if there is extra 1 other then these, else left consecutive ones of (x-1) + right consecutive ones of (x+1)

Time Complexity : O(n)
Space Complexity : O(n)
public class Solution {
    public static int maximum_one(String s)
    {
        // To count all 1's in the string
        int cnt_one = 0;
        int n=s.length();
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1')
                cnt_one++;
        }
        // To store cumulative 1's
        int left[] = new int[n];
        int right[] = new int[n];
        if (s.charAt(0) == '1')
            left[0] = 1;
        else
            left[0] = 0;
    
        if (s.charAt(n-1) == '1')
            right[n - 1] = 1;
        else
            right[n - 1] = 0;
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == '1')
                left[i] = left[i - 1] + 1;
            else
                left[i] = 0;
        }
    
        for (int i = n - 2; i >= 0; i--) {
            if (s.charAt(i) == '1')
                right[i] = right[i + 1] + 1;
    
            else
                right[i] = 0;
        }
    
        int cnt = 0, max_cnt = 0;
        for(int i=0; i<n; ++i )
        max_cnt=Math.max(max_cnt,Math.max(right[i],left[i]));
        for (int i = 1; i < n - 1; i++) {
            if (s.charAt(i) == '0') {
                int sum = left[i - 1] + right[i + 1];
    
                if (sum < cnt_one)
                    cnt = sum + 1;
    
                else
                    cnt = sum;

                max_cnt = Math.max(max_cnt, cnt);
                cnt = 0;
            }
        }
    
        return max_cnt;
    }
    public int solve(String A) {
        return maximum_one(A);
        
    }
}
