Given two arrays of strings A of size N and B of size M.

Return a binary string C where C[i] = '1' if B[i] can be found in dictionary A using exactly one modification in B[i], Else C[i] = '0'.

NOTE: modification is defined as converting a character into another character.



Problem Constraints

1 <= N <= 30000

1 <= M <= 2500

1 <= length of any string either in A or B <= 20

strings contains only lowercase alphabets



Input Format

First argument is the string arrray A.

Second argument is the string array B.



Output Format

Return a binary string C where C[i] = '1' if B[i] can be found in dictionary A using one modification in B[i], Else C[i] = '0'.



Example Input

Input 1:

 A = [data, circle, cricket]
 B = [date, circel, crikket, data, circl]
Input 2:

 A = [hello, world]
 B = [hella, pello, pella]


Example Output

Output 1:

 "10100"
Output 2:

 "110"


Example Explanation

Explanation 1:

 1. date = dat*(can be found in A)
 2. circel =(cannot be found in A using exactly one modification)
 3. crikket = cri*ket(can be found in A)
 4. data = (cannot be found in A using exactly one modification)
 5. circl = (cannot be found in A using exactly one modification)
Explanation 2:

 Only pella cannot be found in A using only one modification.









public class Solution {
        public class TrieNode {
        Character data;
        TrieNode[] children;
        boolean eow;

        TrieNode(Character ch) {
            data = ch;
            children = new TrieNode[26];
            eow = false;
        }
    }
    public String solve(String[] A, String[] B) {
                TrieNode root = inserAll(A);
                      StringBuilder sb = new StringBuilder();
        for(int i=0;i<B.length;i++){
            sb.append(search(B[i],0,root,0)==true?1:0);
        }
        return sb.toString();
    }
        public TrieNode inserAll(String[] A){
        TrieNode root = new TrieNode('0');
        for(String s:A){
            int len = s.length();
                 TrieNode curr =root;
            for(int i=0;i<len;i++){
           
                Character ch = s.charAt(i);
                if(curr.children[ch-'a'] == null){
                   curr.children[ch-'a']=new TrieNode(ch);
                }
                curr= curr.children[ch-'a'];

            }
            curr.eow=true;
        }
        return root;
    }
     public boolean search(String s,int idx ,TrieNode root,int flag){
         int n=s.length();
         boolean ans=false;

         if(idx==n){
         if(flag ==1 && root.eow==true) return true;
         return false;
         }
         char ch = s.charAt(idx);
         if(flag ==0){
             for(TrieNode c:root.children){
                 if(c != null && c.data==ch){
                     ans = ans || search(s,idx+1,c,0);
                 }else if(c != null){
                     ans = ans || search(s,idx+1,c,1);
                 }
             }
         }else{
             TrieNode t =root.children[ch-'a'];
             if(t != null)
             ans = ans || search(s,idx+1,t,1);
         }
         return ans;
         
     }
}
